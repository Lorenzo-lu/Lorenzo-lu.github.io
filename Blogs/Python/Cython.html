<!DOCTYPE html>
    <html>
    <head>
        <meta charset="UTF-8">
        <title>How to use Cython improve your code&quest;</title>
        <style>
</style>
        
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item { list-style-type: none; } .task-list-item-checkbox { margin-left: -20px; vertical-align: middle; }
</style>
        
        
        
    </head>
    <body class="vscode-body vscode-light">
        <style>
.content {
  max-width: 100%;
  margin: 0% 20%;
  font-size:  125%;
  font-family: "times";
}
</style>
<div class = "content">
<h1 id="how-to-use-cython-improve-your-code">How to use Cython improve your code?</h1>
<p>One of the shortcomings of Python is its slow speed. Though we can use packages such as <strong>numpy</strong> for numerical computations, there would be some cases where you cannot directly reach your destination by numpy functions.</p>
<p>Why Python is so slow? When the Python code is running, the data type for each variable is TBD. Its fexiblity simplifies your programming work, but will take longer for Python to figure out the variable types. <strong>Cython</strong> works similar to C, and you have to determine the data types by yourself.</p>
<p>It is simple to create a Cython function in Jupyter Nodebook. Lets using a <strong>Laplacian filter</strong> as an example. The Laplacian filter works in Fourier domain. The first step is to get the Fourier coeficients <code>F</code> from your image by fft2. Don't forget to fftshift it. The Laplacian filter in Fourier domain is like a paraboloid. In Python, if we define it as <code>M</code>, then <code>M[kr][kc] = ( (kr - (n_row-1)/2)**2 + (kc - (n_col-1)/2)**2 )</code>; for instance, <code>np.ndarray([[4, 1, 4],[1, 0, 1],[4, 1, 4]])</code>. A quick method for generating <code>M</code> is using <code>meshgrid</code> function. But if you are not familiar with it, you will probably just do it in loops. If your image is large, generating <code>M</code> will be suffering.</p>
<p>In your first cell, input <code>%load_ext cython </code>. Then move to the next cell, and input</p>
<pre><code><code><div>%%cython
import numpy as np
def Laplacian_filter_Cython((int,int) ndims):
    cdef int n_row;
    cdef int n_col;
    (n_row, n_col) = ndims;

    cdef double [:,:] masked = np.zeros((n_row, n_col));

    cdef int kr;
    cdef int kc;
    for kr in range(n_row):
        for kc in range(n_col):
            masked[kr][kc] = ( (kr - (n_row-1)/2)**2 + (kc - (n_col-1)/2)**2 );
    return np.array(masked);
</div></code></code></pre>
<p>Note that Cython is compatible with numpy. In this <code>%%cython</code> cell, you can write multiple functions. Python can access the Cython functions after <code>def</code>, but won't work with those after <code>cdef</code>.</p>
<p>In the new cell, input <code>mask = Laplacian_filter_Cython((1000,1000));</code>. It means you input a tuple containing numbers of rows and columns into the Cython function. If you want to define a matrix in Cython: <code>double [:]</code> is 1D double array, <code>double [:,:]</code> is 2D double matrix and <code>double [:,:,:]</code> is 3D double tensor. You can also change the <code>double</code> into other types, as long as they are compatible.</p>
<p>Try to find how much faster Cython is than Python!</p>
<p><a href = https://cython.readthedocs.io/en/latest/>To: Cython documentation</a></p>
</div>
    </body>
    </html>